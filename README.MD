# 📝 소개




#### 한 서버 내에서 블랙프라이데이, 수강신청, 이벤트 등 높은 트래픽에 대처하기 위한 Architecture 설계

## 기술 스택

- **Spring Boot, Java, JPA, RabbitMQ**
  <br/>


## 목차

**1. 시스템 아키텍처**
<br>
**2. 계기**
<br>
**3. 구현**
<br/>

<br/>





# 🔨 시스템 아키텍처


![image](https://github.com/user-attachments/assets/8a15ffcf-404c-4f48-89b9-8374ab7491ae)

<br/>
<br/>

# 🌟 계기

- **하나의 서버 내에서 아키텍처 설계를 통한 이점을 가져보자**
  - **필요 이상으로 서버를 띄우는 것은 자원 및 비용 낭비**'
  - **인증/인가 컨테이너를 따로 만들어 보안 로직에 대한 낮은 결합도, 높은 확장성 추구**
  - **하나의 서버 내에서 설계를 통한 트래픽 처리의 이점을 갖기 위함**
  - **직렬적으로 설계시 병목현상 발생, 동적인 대처 불가능**
  - **요청 실패시 데이터 보관 유실 방지**
  - **요청 실패 레이어에서 우선순위를 다시 받아 시도함으로써 에러 대처**

<br/>
<br/>
<br/>


# 💡 구현
- **클라이언트, Gateway API, Auth,  Servce Container로 구분**
  - **각 모듈을 분리함으로써 캡슐화/응집도 강화 결합도 감소를 통한 확장성 증가**
  - **Auth 서버에서 인증/인가 이후엔 주어진 Passport를 통해 로직 수행 각 서비스 컨테이너와 인증/인가 컨테이너 사이의 캡슐화 강화**
- **Routing Key에 맞는 Queue(Service Container)를 호출하게 만듦으로써 병렬적 구조 형성**
  - **동기적 흐름에서 발생할 수 있는 병목현상의 피해 최소화 가능**
  - **트래픽 증가 시 해당 서비스 컨테이너 및 큐의 갯수 증가를 통해 유연한 상황 대처 가능, 상황 종료 시에 롤백**
  - **불필요한 서버를 띄울 필요 없이 확장성 확보, 동적인 대처 가능**
- **요청 실패 시에 재시도, 해당 레이어에서 다시 시도**
  - **요청 실패 지점부터 로직 진행 가능**
  - **요청 실패를 우선순위로 다시 요청함으로써 처음 로직부터 시행할 필요가 사라짐 -> 리소스 낭비 방지**
  - **재시도를 통해 사용자 경험 개선, 시스템 안정성 개선**




<hr/>




